(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[326],{2711:function(i,e,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/opt",function(){return n(4509)}])},4509:function(i,e,n){"use strict";n.r(e),n.d(e,{default:function(){return o}});var l=n(5893),s=n(6282),t=n(7090);let c=function(i){let{children:e}=i;return(0,l.jsx)(t.Z,{active:"opt",children:(0,l.jsx)("div",{className:"content",children:e})})};function r(i){let e={a:"a",code:"code",h1:"h1",hr:"hr",li:"li",nav:"nav",ol:"ol",ul:"ul",...(0,s.a)(),...i.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.nav,{className:"toc",children:(0,l.jsxs)(e.ol,{className:"toc-level toc-level-1",children:[(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#algorithms-and-data-structures",children:"Algorithms and Data Structures"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#cache-utilization",children:"Cache utilization"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#concurrency",children:"Concurrency"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#distributed-compute",children:"Distributed compute"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#simd",children:"SIMD"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#io",children:"I/O"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#misc",children:"Misc"})}),(0,l.jsx)(e.li,{className:"toc-item toc-item-h1",children:(0,l.jsx)(e.a,{className:"toc-link toc-link-h1",href:"#tools",children:"Tools"})})]})}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"Reducing the number of branches"}),"\n",(0,l.jsx)(e.li,{children:"State machines instead of booleans"}),"\n",(0,l.jsx)(e.li,{children:"Faster copy (struct copy will be done using an optimized inline memcpy)"}),"\n",(0,l.jsxs)(e.li,{children:["Cheaper arithmetic","\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"Avoid divisions by creating a table of 1/j and multiply by 1/j instead"}),"\n",(0,l.jsx)(e.li,{children:"Unsigned division is cheaper than signed division"}),"\n",(0,l.jsx)(e.li,{children:"Modulo often be transformed into if-statements"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"Fewer operations"}),"\n",(0,l.jsx)(e.li,{children:"Calculations in loops"}),"\n",(0,l.jsx)(e.li,{children:"Avoid casting"}),"\n",(0,l.jsx)(e.li,{children:"Remove if statements in loops if they are only run for one particular iteration"}),"\n",(0,l.jsx)(e.li,{children:"Use a small number of function arguments to avoid using the stack"}),"\n",(0,l.jsx)(e.li,{children:"Inline functions"}),"\n",(0,l.jsx)(e.li,{children:"Parallelism"}),"\n",(0,l.jsxs)(e.li,{children:["Using the ",(0,l.jsx)(e.code,{children:"restrict"})," keyword"]}),"\n",(0,l.jsx)(e.li,{children:"Double initialization"}),"\n",(0,l.jsx)(e.li,{children:"Useless initialization"}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"algorithms-and-data-structures",children:"Algorithms and Data Structures"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Algorithms optimized for speed may consume more memory due to precomputed data structures or caching"}),"\n",(0,l.jsx)(e.li,{children:'Conversely, algorithms optimized for memory may have to compute values "on the fly" to avoid having them stored in a lookup table.'}),"\n",(0,l.jsx)(e.li,{children:"Not trivial as the best theoretical algorithm may be slower in practice due to how the program interacts with the memory!"}),"\n",(0,l.jsx)(e.li,{children:"EXAMPLE: Sorting"}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"cache-utilization",children:"Cache utilization"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:'Code optimized for speed "mus" exploit the CPU cache more effectively to get faster execution times. However, this is not trivial and platform dependent.'}),"\n",(0,l.jsx)(e.li,{children:"Memory hierarchy"}),"\n",(0,l.jsx)(e.li,{children:"Cache access"}),"\n",(0,l.jsx)(e.li,{children:"Data cache vs Text cache"}),"\n",(0,l.jsx)(e.li,{children:"Cache models and levels"}),"\n",(0,l.jsxs)(e.li,{children:["Spatial locality vs temporal locality","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Instructions and data are normally not accessed in a random order. The order is based on loops, subroutines, data structures, arrays etc."}),"\n",(0,l.jsx)(e.li,{children:"Stack vs Heap performance"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"Virtual memory"}),"\n",(0,l.jsx)(e.li,{children:"Cost effective?"}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"concurrency",children:"Concurrency"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Keep the critical section small"}),"\n",(0,l.jsx)(e.li,{children:"Spin-lock vs semaphore"}),"\n",(0,l.jsx)(e.li,{children:"Lock-free"}),"\n",(0,l.jsx)(e.li,{}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"distributed-compute",children:"Distributed compute"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Big data"}),"\n",(0,l.jsx)(e.li,{children:"MapReduce"}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"simd",children:"SIMD"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsx)(e.h1,{id:"io",children:"I/O"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsx)(e.h1,{id:"misc",children:"Misc"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Loop unrolling"}),"\n",(0,l.jsx)(e.li,{children:"Pointer arithmetic"}),"\n",(0,l.jsx)(e.li,{children:"Compiler optimizations"}),"\n",(0,l.jsx)(e.li,{children:"Bitfields"}),"\n",(0,l.jsx)(e.li,{children:"Bitmaps"}),"\n",(0,l.jsx)(e.li,{children:"Register allocation"}),"\n",(0,l.jsx)(e.li,{children:"Floating point arithmetic"}),"\n",(0,l.jsx)(e.li,{children:"BigInt or 128 bits on 64 bit architecture"}),"\n",(0,l.jsx)(e.li,{children:"Inlining"}),"\n",(0,l.jsxs)(e.li,{children:["Branchless programming (Pipelining)","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Control hazards"}),"\n",(0,l.jsx)(e.li,{children:"Can lead to many stalls in the pipeline, normally the branch is predicted and stalled only if it turns out to be the wrong path. Much better if we can avoid the control statement altogether!"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"Alignment"}),"\n",(0,l.jsxs)(e.li,{children:["RISC vs CISC","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"CISC => Requires fewer instructions, but these instructions require a complex implementation which will make all instructions slow, even the simple instructions."}),"\n",(0,l.jsx)(e.li,{children:"Compilers are often good at making fast code with simple instructions."}),"\n",(0,l.jsx)(e.li,{children:"The longest delay in the circuit determines the clock speed."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["Handcoding assembly for performance?","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Sometimes, but at the cost of efficiency and more lines of code increases the amounts of bugs"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h1,{id:"tools",children:"Tools"}),"\n",(0,l.jsx)(e.hr,{}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"flamegraph"}),"\n"]})]})}function o(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,l.jsx)(c,{...i,children:(0,l.jsx)(r,{...i})})}},6282:function(i,e,n){"use strict";function l(i){return i}n.d(e,{a:function(){return l}})}},function(i){i.O(0,[976,603,90,774,888,179],function(){return i(i.s=2711)}),_N_E=i.O()}]);