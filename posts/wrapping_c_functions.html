<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/789d3182508b19b3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/789d3182508b19b3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5b0b3af323bab63b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5b0b3af323bab63b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-305cb810cde7afac.js" defer=""></script><script src="/_next/static/chunks/main-1e819d43c82e61a4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3bb51e5479d52aef.js" defer=""></script><script src="/_next/static/chunks/c16184b3-1754bfa260bbde28.js" defer=""></script><script src="/_next/static/chunks/956-ecad456ce1733bd3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-17d4c7a621e65cd0.js" defer=""></script><script src="/_next/static/-SwUpiZshXj-qYOyia5Ae/_buildManifest.js" defer=""></script><script src="/_next/static/-SwUpiZshXj-qYOyia5Ae/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><header><div class="header"><a href="/about">about</a><a href="/posts">posts</a><a href="/publications">publications</a><a href="/projects">projects</a><a href="/books">books</a><div class="header-icons"><a href="/feed.xml"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" class="svg-inline--fa fa-rss " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0A64 64 0 1 1 0 416zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a><span><svg style="position:relative;top:2px" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512"><path d="M297.2 248.9C311.6 228.3 320 203.2 320 176c0-70.7-57.3-128-128-128S64 105.3 64 176c0 27.2 8.4 52.3 22.8 72.9c3.7 5.3 8.1 11.3 12.8 17.7l0 0c12.9 17.7 28.3 38.9 39.8 59.8c10.4 19 15.7 38.8 18.3 57.5H109c-2.2-12-5.9-23.7-11.8-34.5c-9.9-18-22.2-34.9-34.5-51.8l0 0 0 0c-5.2-7.1-10.4-14.2-15.4-21.4C27.6 247.9 16 213.3 16 176C16 78.8 94.8 0 192 0s176 78.8 176 176c0 37.3-11.6 71.9-31.4 100.3c-5 7.2-10.2 14.3-15.4 21.4l0 0 0 0c-12.3 16.8-24.6 33.7-34.5 51.8c-5.9 10.8-9.6 22.5-11.8 34.5H226.4c2.6-18.7 7.9-38.6 18.3-57.5c11.5-20.9 26.9-42.1 39.8-59.8l0 0 0 0 0 0c4.7-6.4 9-12.4 12.7-17.7zM192 128c-26.5 0-48 21.5-48 48c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-44.2 35.8-80 80-80c8.8 0 16 7.2 16 16s-7.2 16-16 16zm0 384c-44.2 0-80-35.8-80-80V416H272v16c0 44.2-35.8 80-80 80z"></path></svg></span></div></div></header><div class="posts"><div class="post"><h1>Wrapping C functions</h1><div><p>Let's say you want to overwrite an API-function located in a library that you don't have any control over or a standard
library function. This is useful when you want to stub that function in some test bench or insert debugging information
in the function itself. To do this, we can make use of C-macros. Let's say we want to overwrite <code>malloc</code>. We first
define our own malloc like so:</p>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">my_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>Then we can define the following macro to replace all instances of <code>malloc</code> with our newly defined <code>my_malloc</code>:</p>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">malloc</span> <span class="token expression">my_malloc</span></span>
</code></pre></div>
<p>Compiling and running yields us:</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> clang main.c <span class="token operator">&#x26;&#x26;</span> ./a.out
my_malloc
</code></pre></div>
<p>What if we want to make use of the original <code>malloc</code> in our newly created <code>my_malloc</code>? This could be problematic as the define replaces all instances of <code>malloc</code> with <code>my_malloc</code>. So creating a <code>my_malloc</code> like this will cause the macro to be recursively executed:</p>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">my_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>Compling and running this instead will result in:</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> clang main.c <span class="token operator">&#x26;&#x26;</span> ./a.out
my_mallocmy_mallocm<span class="token punctuation">..</span>.y_malloSegmentation fault <span class="token punctuation">(</span>core dumped<span class="token punctuation">)</span>
</code></pre></div>
<p>Where the dots represent <code>my_malloc</code> being printed MANY times.</p>
<p>To make this work, we have to place <code>my_malloc</code> in a separate source file. Since source files are preprocessed to
translation units along with all the includes and compiled separately from each other, a define in e.g., <code>main.c</code> will not affect a wrapper in e.g., <code>malloc.c</code>. So we create the following files:</p>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token comment">// malloc.c</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">my_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token comment">// main.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">malloc</span> <span class="token expression">my_malloc</span></span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">my_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>Now it is possible to compile and execute without all those recursive calls:</p>
<div class="remark-highlight"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> clang main.c malloc.c <span class="token operator">&#x26;&#x26;</span> ./a.out
my_malloc
</code></pre></div>
<p>We can now wrap the function declaration in a header file and include it wherever we want to
overwrite <code>malloc</code>:</p>
<div class="remark-highlight"><pre class="language-c"><code class="language-c"><span class="token comment">// malloc.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">malloc</span> <span class="token expression">my_malloc</span></span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">my_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Wrapping C functions","date":"2025-03-11","slug":"wrapping_c_functions","content":"\u003cp\u003eLet's say you want to overwrite an API-function located in a library that you don't have any control over or a standard\nlibrary function. This is useful when you want to stub that function in some test bench or insert debugging information\nin the function itself. To do this, we can make use of C-macros. Let's say we want to overwrite \u003ccode\u003emalloc\u003c/code\u003e. We first\ndefine our own malloc like so:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003emy_malloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003esize_t\u003c/span\u003e size\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eprintf\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"my_malloc\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token constant\"\u003eNULL\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThen we can define the following macro to replace all instances of \u003ccode\u003emalloc\u003c/code\u003e with our newly defined \u003ccode\u003emy_malloc\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token macro property\"\u003e\u003cspan class=\"token directive-hash\"\u003e#\u003c/span\u003e\u003cspan class=\"token directive keyword\"\u003edefine\u003c/span\u003e \u003cspan class=\"token macro-name\"\u003emalloc\u003c/span\u003e \u003cspan class=\"token expression\"\u003emy_malloc\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eCompiling and running yields us:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e clang main.c \u003cspan class=\"token operator\"\u003e\u0026#x26;\u0026#x26;\u003c/span\u003e ./a.out\nmy_malloc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhat if we want to make use of the original \u003ccode\u003emalloc\u003c/code\u003e in our newly created \u003ccode\u003emy_malloc\u003c/code\u003e? This could be problematic as the define replaces all instances of \u003ccode\u003emalloc\u003c/code\u003e with \u003ccode\u003emy_malloc\u003c/code\u003e. So creating a \u003ccode\u003emy_malloc\u003c/code\u003e like this will cause the macro to be recursively executed:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003emy_malloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003esize_t\u003c/span\u003e size\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eprintf\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"my_malloc\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003emalloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esize\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eCompling and running this instead will result in:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e clang main.c \u003cspan class=\"token operator\"\u003e\u0026#x26;\u0026#x26;\u003c/span\u003e ./a.out\nmy_mallocmy_mallocm\u003cspan class=\"token punctuation\"\u003e..\u003c/span\u003e.y_malloSegmentation fault \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecore dumped\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhere the dots represent \u003ccode\u003emy_malloc\u003c/code\u003e being printed MANY times.\u003c/p\u003e\n\u003cp\u003eTo make this work, we have to place \u003ccode\u003emy_malloc\u003c/code\u003e in a separate source file. Since source files are preprocessed to\ntranslation units along with all the includes and compiled separately from each other, a define in e.g., \u003ccode\u003emain.c\u003c/code\u003e will not affect a wrapper in e.g., \u003ccode\u003emalloc.c\u003c/code\u003e. So we create the following files:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token comment\"\u003e// malloc.c\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003emy_malloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003esize_t\u003c/span\u003e size\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eprintf\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"my_malloc\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003emalloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esize\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token comment\"\u003e// main.c\u003c/span\u003e\n\u003cspan class=\"token macro property\"\u003e\u003cspan class=\"token directive-hash\"\u003e#\u003c/span\u003e\u003cspan class=\"token directive keyword\"\u003edefine\u003c/span\u003e \u003cspan class=\"token macro-name\"\u003emalloc\u003c/span\u003e \u003cspan class=\"token expression\"\u003emy_malloc\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003emy_malloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003esize_t\u003c/span\u003e size\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e ptr \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003emalloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e4\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow it is possible to compile and execute without all those recursive calls:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e clang main.c malloc.c \u003cspan class=\"token operator\"\u003e\u0026#x26;\u0026#x26;\u003c/span\u003e ./a.out\nmy_malloc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe can now wrap the function declaration in a header file and include it wherever we want to\noverwrite \u003ccode\u003emalloc\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-c\"\u003e\u003ccode class=\"language-c\"\u003e\u003cspan class=\"token comment\"\u003e// malloc.h\u003c/span\u003e\n\u003cspan class=\"token macro property\"\u003e\u003cspan class=\"token directive-hash\"\u003e#\u003c/span\u003e\u003cspan class=\"token directive keyword\"\u003edefine\u003c/span\u003e \u003cspan class=\"token macro-name\"\u003emalloc\u003c/span\u003e \u003cspan class=\"token expression\"\u003emy_malloc\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token function\"\u003emy_malloc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003esize_t\u003c/span\u003e size\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"wrapping_c_functions"},"buildId":"-SwUpiZshXj-qYOyia5Ae","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>